#include "Processor.h"
#include "Config.h"
#include "Controller.h"
#include "SpeedyController.h"
#include "Memory.h"
#include "DRAM.h"
#include "Statistics.h"
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <stdlib.h>
#include <functional>
#include <map>
#include <utility>
#include "CXLInterface.h"
#include "RamDevice.h"

/* Standards */
#include "Gem5Wrapper.h"
#include "DDR3.h"
#include "DDR4.h"
#include "DSARP.h"
#include "GDDR5.h"
#include "LPDDR3.h"
#include "LPDDR4.h"
#include "WideIO.h"
#include "WideIO2.h"
#include "HBM.h"
#include "SALP.h"
#include "ALDRAM.h"
#include "TLDRAM.h"
#include "STTMRAM.h"
#include "PCM.h"

using namespace std;
using namespace ramulator;
using namespace CXL_IF;

bool ramulator::warmup_complete = false;

uint64_t static req_id = 0;
template<typename T>
bool update_dramtrace(Memory<T, Controller>& memory, CXL_if_buf& inp_buf, dramtrace_state& state);
// template<typename T>
// void run_dramtrace(const Config& configs, Memory<T, Controller>& memory, const char* tracename) {

// typedef struct
// {
// 	bool stall, end, idle;
//     int reads, writes, clks;
// 	status_type status;
// }dramtrace_state;

template<typename T>
void run_dramtrace(Memory<T, Controller>& memory, CXL_if_buf& inp_buf)
{
	dramtrace_state state;
	state.stall = false;
	state.end = false;
	state.idle = false;
    state.reads = 0;
	state.writes = 0;
	state.clks = 0;
	state.status = status_type::VALID;

	bool is_sim_finished = false;

	uint64_t req_id = 0;

	while(!is_sim_finished)
	{
		// Request req(0x0000000, Request::Type::READ, req_id, ramulator_req_complete);
		is_sim_finished = update_dramtrace(memory,inp_buf,state);
		// req_id++;
	}
}

template<typename T>
bool update_dramtrace(Memory<T, Controller>& memory, CXL_if_buf& inp_buf, dramtrace_state& state) 
{
	// bool stall = false, end = false, idle = false;
    // int reads = 0, writes = 0, clks = 0;
    long addr = 0;
    Request::Type type = Request::Type::READ;
    // map<int, int> latencies;
    // auto read_complete = [&latencies](Request& r){latencies[r.depart - r.arrive]++;};
	// status_type status;

    if (!state.end || memory.pending_requests()){
        if (!state.end && !state.stall){
            // end = !trace.get_dramtrace_request(addr, type);
            state.status = inp_buf.get_dramtrace_request(addr, type, req_id);
			state.idle = state.status == status_type::VALID ? false : true;
			state.end = state.status == status_type::END ? true : false;
			// printf("Addr %x, Type %d\n", addr, type);
        }

        if (!state.end && !state.idle){
			Request req(addr, type, req_id, ramulator_req_complete);
			// req_id++;
            req.addr = addr;
            req.type = type;
            state.stall = !memory.send(req);
			printf("Sent Mem Req, Addr %x, Type %d, ID %lu\n",req.addr, req.type, req.req_id);
            if (!state.stall){
                if (type == Request::Type::READ) state.reads++;
                else if (type == Request::Type::WRITE) state.writes++;
            }
        }
        else {
            memory.set_high_writeq_watermark(0.0f); // make sure that all write requests in the
                                                    // write queue are drained
        }

        memory.tick();
        state.clks ++;
        Stats::curTick++; // memory clock, global, for Statistics
		return false;
    }
	return true;
}

template<typename T>
void finish_dramtrace(Memory<T, Controller>& memory)
{
	// This a workaround for statistics set only initially lost in the end
    memory.finish();
    Stats::statlist.printall();
	printf("CurTick %lu\n",Stats::curTick);
}

template <typename T>
void run_cputrace(const Config& configs, Memory<T, Controller>& memory, const std::vector<const char *>& files)
{
    int cpu_tick = configs.get_cpu_tick();
    int mem_tick = configs.get_mem_tick();
    auto send = bind(&Memory<T, Controller>::send, &memory, placeholders::_1);
    Processor proc(configs, files, send, memory);

    long warmup_insts = configs.get_warmup_insts();
    bool is_warming_up = (warmup_insts != 0);

    for(long i = 0; is_warming_up; i++){
        proc.tick();
        Stats::curTick++;
        if (i % cpu_tick == (cpu_tick - 1))
            for (int j = 0; j < mem_tick; j++)
                memory.tick();

        is_warming_up = false;
        for(int c = 0; c < proc.cores.size(); c++){
            if(proc.cores[c]->get_insts() < warmup_insts)
                is_warming_up = true;
        }

        if (is_warming_up && proc.has_reached_limit()) {
            printf("WARNING: The end of the input trace file was reached during warmup. "
                    "Consider changing warmup_insts in the config file. \n");
            break;
        }

    }

    warmup_complete = true;
    printf("Warmup complete! Resetting stats...\n");
    Stats::reset_stats();
    proc.reset_stats();
    assert(proc.get_insts() == 0);

    printf("Starting the simulation...\n");

    int tick_mult = cpu_tick * mem_tick;
    for (long i = 0; ; i++) {
        if (((i % tick_mult) % mem_tick) == 0) { // When the CPU is ticked cpu_tick times,
                                                 // the memory controller should be ticked mem_tick times
            proc.tick();
            Stats::curTick++; // processor clock, global, for Statistics

            if (configs.calc_weighted_speedup()) {
                if (proc.has_reached_limit()) {
                    break;
                }
            } else {
                if (configs.is_early_exit()) {
                    if (proc.finished())
                    break;
                } else {
                if (proc.finished() && (memory.pending_requests() == 0))
                    break;
                }
            }
        }

        if (((i % tick_mult) % cpu_tick) == 0) // TODO_hasan: Better if the processor ticks the memory controller
            memory.tick();

    }
    // This a workaround for statistics set only initially lost in the end
    memory.finish();
    Stats::statlist.printall();
}

template<typename T>
void start_run(const Config& configs, T* spec, const vector<const char*>& files) {
	// initiate controller and memory
	int C = configs.get_channels(), R = configs.get_ranks();
	// Check and Set channel, rank number
	spec->set_channel_number(C);
	spec->set_rank_number(R);
	std::vector<Controller<T>*> ctrls;
	for (int c = 0 ; c < C ; c++) {
	  DRAM<T>* channel = new DRAM<T>(spec, T::Level::Channel);
	  channel->id = c;
	  channel->regStats("");
	  Controller<T>* ctrl = new Controller<T>(configs, channel);
	  ctrls.push_back(ctrl);
	}
	Memory<T, Controller> memory(configs, ctrls);

  	CXL_if_buf buffer;
	buffer.buf_add(build_req(0x12345680,Request::Type::READ,status_type::VALID)); 
	buffer.buf_add(build_req(0x4cbd56c0,Request::Type::WRITE,status_type::VALID)); 
	buffer.buf_add(build_req(0x35d46f00,Request::Type::READ,status_type::VALID)); 
	// buffer.buf_add(build_req(0x35d46f00,Request::Type::READ,status_type::VALID)); 
	// buffer.buf_add(build_req(0x35d4ab00,Request::Type::READ,status_type::VALID)); 
	// buffer.buf_add(build_req(0x35d46700,Request::Type::READ,status_type::VALID)); 
	// buffer.buf_add(build_req(0x35d44300,Request::Type::READ,status_type::VALID)); 
	// buffer.buf_add(build_req(0x35d46d00,Request::Type::READ,status_type::VALID)); 
	buffer.buf_add(build_req(0x696fed40,Request::Type::WRITE,status_type::VALID)); 
	// buffer.buf_add(build_req(0x7876af80,Request::Type::READ,status_type::IDLE)); 
	// buffer.buf_add(build_req(0x7876af80,Request::Type::READ,status_type::IDLE)); 
	// buffer.buf_add(build_req(0x7876af80,Request::Type::READ,status_type::IDLE)); 
	// buffer.buf_add(build_req(0x7876af80,Request::Type::READ,status_type::VALID)); 
	buffer.buf_add(build_req(0x7876af80,Request::Type::READ,status_type::VALID)); 
	buffer.buf_add(build_req(0x7876af80,Request::Type::READ,status_type::END)); 

  	assert(files.size() != 0);
  	if (configs["trace_type"] == "CPU") {
  		run_cputrace(configs, memory, files);
  	} else if (configs["trace_type"] == "DRAM") {
  		// run_dramtrace(configs, memory, files[0]);
  		// run_dramtrace(configs, memory, buffer);
  		run_dramtrace(memory, buffer);
		finish_dramtrace(memory);
  	}
}



int simulator_top()
{
    // if (argc < 2) {
    //     printf("Usage: %s <configs-file> --mode=cpu,dram [--stats <filename>] <trace-filename1> <trace-filename2>\n"
    //         "Example: %s ramulator-configs.cfg --mode=cpu cpu.trace cpu.trace\n", argv[0], argv[0]);
    //     return 0;
    // }

    Config configs("configs/DDR4-config.cfg");

    const std::string& standard = configs["standard"];
    assert(standard != "" || "DRAM standard should be specified.");

    // const char *trace_type = strstr(argv[2], "=");
    const char *trace_type = "dram";
    // trace_type++;
    if (strcmp(trace_type, "cpu") == 0) {
      configs.add("trace_type", "CPU");
    } else if (strcmp(trace_type, "dram") == 0) {
      configs.add("trace_type", "DRAM");
    } else {
      printf("invalid trace type: %s\n", trace_type);
      assert(false);
    }

    int trace_start = 3;
    string stats_out;
    // if (strcmp(argv[trace_start], "--stats") == 0) {
    //   Stats::statlist.output(argv[trace_start+1]);
    //   stats_out = argv[trace_start+1];
    //   trace_start += 2;
    // } else {
    //   Stats::statlist.output(standard+".stats");
    //   stats_out = standard + string(".stats");
    // }

    Stats::statlist.output(standard+".stats");
    stats_out = standard + string(".stats");

    // A separate file defines mapping for easy config.
    // if (strcmp(argv[trace_start], "--mapping") == 0) {
    //   configs.add("mapping", argv[trace_start+1]);
    //   trace_start += 2;
    // } else {
    //   configs.add("mapping", "defaultmapping");
    // }
    
	configs.add("mapping", "defaultmapping");

    // std::vector<const char*> files(&argv[trace_start], &argv[argc]);
    std::vector<const char*> files;
	files.push_back("dram.trace");
    configs.set_core_num(1);



    if (standard == "DDR3") {
      DDR3* ddr3 = new DDR3(configs["org"], configs["speed"]);
      start_run(configs, ddr3, files);
    } else if (standard == "DDR4") {
      DDR4* ddr4 = new DDR4(configs["org"], configs["speed"]);
      start_run(configs, ddr4, files);
    } else if (standard == "SALP-MASA") {
      SALP* salp8 = new SALP(configs["org"], configs["speed"], "SALP-MASA", configs.get_subarrays());
      start_run(configs, salp8, files);
    } else if (standard == "LPDDR3") {
      LPDDR3* lpddr3 = new LPDDR3(configs["org"], configs["speed"]);
      start_run(configs, lpddr3, files);
    } else if (standard == "LPDDR4") {
      // total cap: 2GB, 1/2 of others
      LPDDR4* lpddr4 = new LPDDR4(configs["org"], configs["speed"]);
      start_run(configs, lpddr4, files);
    } else if (standard == "GDDR5") {
      GDDR5* gddr5 = new GDDR5(configs["org"], configs["speed"]);
      start_run(configs, gddr5, files);
    } else if (standard == "HBM") {
      HBM* hbm = new HBM(configs["org"], configs["speed"]);
      start_run(configs, hbm, files);
    } else if (standard == "WideIO") {
      // total cap: 1GB, 1/4 of others
      WideIO* wio = new WideIO(configs["org"], configs["speed"]);
      start_run(configs, wio, files);
    } else if (standard == "WideIO2") {
      // total cap: 2GB, 1/2 of others
      WideIO2* wio2 = new WideIO2(configs["org"], configs["speed"], configs.get_channels());
      wio2->channel_width *= 2;
      start_run(configs, wio2, files);
    } else if (standard == "STTMRAM") {
      STTMRAM* sttmram = new STTMRAM(configs["org"], configs["speed"]);
      start_run(configs, sttmram, files);
    } else if (standard == "PCM") {
      PCM* pcm = new PCM(configs["org"], configs["speed"]);
      start_run(configs, pcm, files);
    }
    // Various refresh mechanisms
      else if (standard == "DSARP") {
      DSARP* dsddr3_dsarp = new DSARP(configs["org"], configs["speed"], DSARP::Type::DSARP, configs.get_subarrays());
      start_run(configs, dsddr3_dsarp, files);
    } else if (standard == "ALDRAM") {
      ALDRAM* aldram = new ALDRAM(configs["org"], configs["speed"]);
      start_run(configs, aldram, files);
    } else if (standard == "TLDRAM") {
      TLDRAM* tldram = new TLDRAM(configs["org"], configs["speed"], configs.get_subarrays());
      start_run(configs, tldram, files);
    }

    printf("Simulation done. Statistics written to %s\n", stats_out.c_str());

    return 0;
}

int main(int argc, const char *argv[])
{
	// simulator_top();
	RamDevice ram;
	ram.ramulator_init();
	ram.run_trace();
	return 0;
}